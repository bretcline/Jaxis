//------------------------------------------------------------------------------
// <auto-generated>
//    This code was generated from a template.
//
//    Manual changes to this file may cause unexpected behavior in your application.
//    Manual changes to this file will be overwritten if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Objects;
using System.Linq;
using System.Linq.Expressions;
using Jaxis.DrinkInventory.Reporting.Data.POCO;
using Jaxis.DrinkInventory.Reporting.DataInterfaces;
using Jaxis.Util.Log4Net;

namespace Jaxis.DrinkInventory.Reporting.Data
{
    public class DataManagerFactory : IDataManagerFactory, IDisposable
    {
    	private DrinkReportingEntities m_Context;
    	protected DataManagerFactory( )
    	{
    		try
    		{
    			m_Context = new DrinkReportingEntities( );
    		}
    		catch( Exception _ex )
    		{
    			Log.WriteException( "Problem in DataManagerFactory constructor.", _ex );
    			throw;
    		}
    	}
    	
    	public IDataManager<T> Manage<T> ( )
    	{
    		try
    		{
    			return GetType( ).GetProperties( ).Where( p => "I" + p.Name == typeof( T ).Name ).FirstOrDefault( ).GetValue( this, null ) as IDataManager<T>;
    		}
    		catch
    		{
    			throw new Exception( string.Format( "DataManagerFactory does not know how to manage type {0}", typeof( T ) ) );
    		}
    	}
    
    	private IAlertManager m_Alert;
    	public IAlertManager Alert
    	{
    		get
    		{
    			return m_Alert ?? ( m_Alert = new AlertManager( this, m_Context ) );
    		}
    	}
    	private IAreaMembershipManager m_AreaMembership;
    	public IAreaMembershipManager AreaMembership
    	{
    		get
    		{
    			return m_AreaMembership ?? ( m_AreaMembership = new AreaMembershipManager( this, m_Context ) );
    		}
    	}
    	private IAreaManager m_Area;
    	public IAreaManager Area
    	{
    		get
    		{
    			return m_Area ?? ( m_Area = new AreaManager( this, m_Context ) );
    		}
    	}
    	private IColumnManager m_Column;
    	public IColumnManager Column
    	{
    		get
    		{
    			return m_Column ?? ( m_Column = new ColumnManager( this, m_Context ) );
    		}
    	}
    	private IDeviceManager m_Device;
    	public IDeviceManager Device
    	{
    		get
    		{
    			return m_Device ?? ( m_Device = new DeviceManager( this, m_Context ) );
    		}
    	}
    	private IOrganizationManager m_Organization;
    	public IOrganizationManager Organization
    	{
    		get
    		{
    			return m_Organization ?? ( m_Organization = new OrganizationManager( this, m_Context ) );
    		}
    	}
    	private IParameterManager m_Parameter;
    	public IParameterManager Parameter
    	{
    		get
    		{
    			return m_Parameter ?? ( m_Parameter = new ParameterManager( this, m_Context ) );
    		}
    	}
    	private IPOSTicketItemManager m_POSTicketItem;
    	public IPOSTicketItemManager POSTicketItem
    	{
    		get
    		{
    			return m_POSTicketItem ?? ( m_POSTicketItem = new POSTicketItemManager( this, m_Context ) );
    		}
    	}
    	private IPourManager m_Pour;
    	public IPourManager Pour
    	{
    		get
    		{
    			return m_Pour ?? ( m_Pour = new PourManager( this, m_Context ) );
    		}
    	}
    	private IReportManager m_Report;
    	public IReportManager Report
    	{
    		get
    		{
    			return m_Report ?? ( m_Report = new ReportManager( this, m_Context ) );
    		}
    	}
    	private ISchemaManager m_Schema;
    	public ISchemaManager Schema
    	{
    		get
    		{
    			return m_Schema ?? ( m_Schema = new SchemaManager( this, m_Context ) );
    		}
    	}
    	private ISecurityViewManager m_SecurityView;
    	public ISecurityViewManager SecurityView
    	{
    		get
    		{
    			return m_SecurityView ?? ( m_SecurityView = new SecurityViewManager( this, m_Context ) );
    		}
    	}
    	private ISessionManager m_Session;
    	public ISessionManager Session
    	{
    		get
    		{
    			return m_Session ?? ( m_Session = new SessionManager( this, m_Context ) );
    		}
    	}
    	private IUPCManager m_UPC;
    	public IUPCManager UPC
    	{
    		get
    		{
    			return m_UPC ?? ( m_UPC = new UPCManager( this, m_Context ) );
    		}
    	}
    	private IUserGroupMembershipManager m_UserGroupMembership;
    	public IUserGroupMembershipManager UserGroupMembership
    	{
    		get
    		{
    			return m_UserGroupMembership ?? ( m_UserGroupMembership = new UserGroupMembershipManager( this, m_Context ) );
    		}
    	}
    	private IUserGroupManager m_UserGroup;
    	public IUserGroupManager UserGroup
    	{
    		get
    		{
    			return m_UserGroup ?? ( m_UserGroup = new UserGroupManager( this, m_Context ) );
    		}
    	}
    	private IUserGroupXOrganizationManager m_UserGroupXOrganization;
    	public IUserGroupXOrganizationManager UserGroupXOrganization
    	{
    		get
    		{
    			return m_UserGroupXOrganization ?? ( m_UserGroupXOrganization = new UserGroupXOrganizationManager( this, m_Context ) );
    		}
    	}
    	private IUserManager m_User;
    	public IUserManager User
    	{
    		get
    		{
    			return m_User ?? ( m_User = new UserManager( this, m_Context ) );
    		}
    	}
    
    	public static IDataManagerFactory Get( )
    	{
    		return new DataManagerFactory( );
    	}
    
    	public void Dispose( )
    	{
    		m_Context.Dispose( );
    	}
    
    	public int SaveChanges( )
    	{
    		try
    		{
    			return m_Context.SaveChanges( );
    		}
    		catch ( Exception _ex )
    		{
    			Log.WriteException( "Problem in DataManagerFactory.SaveChanges.", _ex );
    			throw;
    		}
    	}
    }
    
    public abstract partial class DataManager<I, C> where C : class, IDomainObject, I, new( ) where I : IDomainObject
    {
    	protected DrinkReportingEntities m_Context;
    	protected IDataManagerFactory m_Factory;
    
    	public abstract I Create( );
    
    	// This must be overridden by every Manager whose object's PrimaryKey is not a Guid.  See UPCManager.
    	public virtual I Save( I _item )
    	{
    		return Save( _item, ( ) => Get( _item.Id ) );
    	}
    
    	protected I Save( I _item, Func<I> _getter )
    	{
    		I rc;
    		try
    		{
    			OnSaving( _item );
    
    			var set = m_Context.GetObjectSet<I, C>( );
    
    			var entityKey = m_Context.CreateEntityKey( set.EntitySet.Name, _item );
    
    			ObjectStateEntry stateEntry = null;
       			if( m_Context.ObjectStateManager.TryGetObjectStateEntry( entityKey, out stateEntry ) )
    			{
    				rc = ProcessExistingItem( set.EntitySet.Name, _item, stateEntry );
    			}
    			else
       			{
    				// If IsNew, we can put it in the context and set it's state to Added.
    				if( _item.IsNew )
    				{
    					rc = ProcessNewItem( set.EntitySet.Name, _item );
    				}
    				// Otherwise, try to get the item from the database.
    				else
    				{
    					var oldItem = _getter( );
    					// If it is not found, it must be new despite the IsNew flag.
    					if( oldItem == null )
    					{
    						rc = ProcessNewItem( set.EntitySet.Name, _item );
    					}
    					else
    					// If it is found, it is now in the context and ApplyCurrentValues will update it.
    					{
    						rc = ProcessExistingItem( set.EntitySet.Name, _item, m_Context.ObjectStateManager.GetObjectStateEntry( oldItem ) );
    					}
    				}
    			}
    			// By now, if the item was new, it is no longer.
    			_item.IsNew = false;
    			return rc;
    		}
    		catch( Exception _ex )
    		{
    			Log.WriteException( string.Format( "Problem in DataManager.Save for {0}.", _item.GetType( ).Name ), _ex );
    			throw( _ex );
    		}
    	}
    
    	private I ProcessExistingItem( string _setName, IDomainObject _item, ObjectStateEntry _entry )
    	{
    		var updatedItem = m_Context.ApplyCurrentValues( _setName, ( C ) _item );
            if ( _entry.State == EntityState.Modified )
            {
    			// Only change ModifiedOn if something else changed as well.
                updatedItem.ModifiedOn = DateTime.Now;
    			_entry.SetModifiedProperty( "ModifiedOn" );
            }
    		return ( I ) updatedItem;
    	}
    
    	private I ProcessNewItem( string _setName, IDomainObject _item )
    	{
    		if( _item.ModifiedOn == DateTime.MinValue )
    		{
    			_item.ModifiedOn = DateTime.Now;
    		}
    		m_Context.AttachTo( _setName, _item );
    		m_Context.ObjectStateManager.GetObjectStateEntry( _item ).ChangeState( EntityState.Added );
    		return ( I ) _item;
    	}
    
    	public virtual void Delete( I _item )
    	{
    		try
    		{
    			var set = m_Context.GetObjectSet<I, C>( );
    			var entityKey = m_Context.CreateEntityKey( set.EntitySet.Name, _item );
    			ObjectStateEntry stateEntry = null;
    			if ( !m_Context.ObjectStateManager.TryGetObjectStateEntry( entityKey, out stateEntry ) )
    			{
    				m_Context.AttachTo( set.EntitySet.Name, _item );
    		    }
    			m_Context.DeleteObject( _item );
    		}
    		catch( Exception _ex )
    		{
    			Log.WriteException( string.Format( "Problem in DataManager.Delete for {0}.", _item.GetType( ).Name ), _ex );
    			throw( _ex );
    		}
    	}
    
    	public abstract void Delete( Guid _id );
    
    	public abstract int Delete( Expression<Func<I, bool>> _predicate );
    
    	public virtual IQueryable<I> GetAll( )
    	{
    		return m_Context.GetObjectSet<I, C>( );
    	}
    
    	// This must be overridden by every Manager whose object's PrimaryKey is not a Guid.  See UPCManager.
    	public virtual I Get( Guid _id )
    	{
        	var set = m_Context.GetObjectSet<I, C>( );
    		// By constructing an EntityKey, we can use TryGetObjectByKey, which will not go to the database if the desired object is already in the Context.
        	var tempObject = new C( );
            tempObject.Id = _id;
            var key = m_Context.CreateEntityKey( set.EntitySet.Name, tempObject );
    
            object targetObject = null;
    		m_Context.TryGetObjectByKey( key, out targetObject );    	
    		return ( I ) targetObject;
    	}
    
    	// Typically, Hydrate is used to get all single related objects and a List<Guid> for any collections of related objects.
    	// Set _includeRelatedObjects to true to get complete objects in those collections, as well.
    	public virtual void Hydrate( I _item, bool _includeRelatedObjects = false ) { }
    
    	protected virtual void OnCreated( I _item ) { }
    	protected virtual void OnSaving( I _item ) { }
    }
    
    public partial class AlertManager : DataManager<IAlert, Alert>, IAlertManager, IDataManager
    {
    	public AlertManager ( IDataManagerFactory _factory, DrinkReportingEntities _context )
    	{
    		m_Factory = _factory;
    		m_Context = _context;
    	}
    
    	public override IAlert Create( )
    	{
    		var item = new Alert( );
    		item.AlertId = Guid.NewGuid( );
    		item.IsNew = true;
    		item.ModifiedOn = DateTime.Now;
    		OnCreated( item );
    		return item;
    	}
    
    	public override void Delete( Guid _id )
        {
    		// If we knew that there were no foreign keys involved, we could instantiate an item and set its id and call delete without
    		// first going to the database; but, if a foreign key is involved, that short-cut will cause problems in the context.
    		// Thus, it is safer to go get the item, even though it costs a database read.
    
    		// The item to be deleted might have just been added in this context. Check there first, because it won't be in the database.
    
    		try
    		{
    			var addedEntries = m_Context.ObjectStateManager.GetObjectStateEntries( EntityState.Added );
    			var match = addedEntries.FirstOrDefault( c => ( ( Alert ) c.Entity ).AlertId == _id );
    			IAlert item = match == null ? Get( _id ) : match.Entity as IAlert;
    			Delete( item );
    		}
    		catch ( Exception _ex )
    		{
    			Log.WriteException( string.Format( "Problem in DataManager.Delete for {0} - {1}.", "Alert", _id ), _ex );
    			throw;
    		}
        }
    
    	public override int Delete( Expression<Func<IAlert, bool>> _predicate )
    	{
    		string sql = string.Empty;
    		try
    		{
    			var query = ( ObjectQuery<Guid>) m_Context.GetObjectSet<IAlert, Alert>( )
    				.Where( _predicate )
    				.Select( item => item.AlertId );
    			sql = string.Format( "DELETE FROM [Alerts] WHERE [AlertId] IN ({0})", query.ToTraceString( ) );
    			var parameters = new List<System.Data.SqlClient.SqlParameter>( );
    			foreach ( ObjectParameter parameter in query.Parameters )
    			{
    				parameters.Add( new System.Data.SqlClient.SqlParameter { ParameterName = parameter.Name, Value = parameter.Value } );
    			}
    			return m_Context.ExecuteStoreCommand( sql, parameters.ToArray( ) );
    		}
    		catch( Exception _ex )
    		{
    			Log.WriteException( string.Format( "Problem in DataManager.Delete(Expression) for {0} {1}", "Alert", sql ), _ex );
    			throw;
    		}
    	}
    }
    
    public partial class AreaMembershipManager : DataManager<IAreaMembership, AreaMembership>, IAreaMembershipManager, IDataManager
    {
    	public AreaMembershipManager ( IDataManagerFactory _factory, DrinkReportingEntities _context )
    	{
    		m_Factory = _factory;
    		m_Context = _context;
    	}
    
    	public override IAreaMembership Create( )
    	{
    		var item = new AreaMembership( );
    		item.AreaMembershipId = Guid.NewGuid( );
    		item.IsNew = true;
    		item.ModifiedOn = DateTime.Now;
    		OnCreated( item );
    		return item;
    	}
    
    	public override void Delete( Guid _id )
        {
    		// If we knew that there were no foreign keys involved, we could instantiate an item and set its id and call delete without
    		// first going to the database; but, if a foreign key is involved, that short-cut will cause problems in the context.
    		// Thus, it is safer to go get the item, even though it costs a database read.
    
    		// The item to be deleted might have just been added in this context. Check there first, because it won't be in the database.
    
    		try
    		{
    			var addedEntries = m_Context.ObjectStateManager.GetObjectStateEntries( EntityState.Added );
    			var match = addedEntries.FirstOrDefault( c => ( ( AreaMembership ) c.Entity ).AreaMembershipId == _id );
    			IAreaMembership item = match == null ? Get( _id ) : match.Entity as IAreaMembership;
    			Delete( item );
    		}
    		catch ( Exception _ex )
    		{
    			Log.WriteException( string.Format( "Problem in DataManager.Delete for {0} - {1}.", "AreaMembership", _id ), _ex );
    			throw;
    		}
        }
    
    	public override int Delete( Expression<Func<IAreaMembership, bool>> _predicate )
    	{
    		string sql = string.Empty;
    		try
    		{
    			var query = ( ObjectQuery<Guid>) m_Context.GetObjectSet<IAreaMembership, AreaMembership>( )
    				.Where( _predicate )
    				.Select( item => item.AreaMembershipId );
    			sql = string.Format( "DELETE FROM [AreaMemberships] WHERE [AreaMembershipId] IN ({0})", query.ToTraceString( ) );
    			var parameters = new List<System.Data.SqlClient.SqlParameter>( );
    			foreach ( ObjectParameter parameter in query.Parameters )
    			{
    				parameters.Add( new System.Data.SqlClient.SqlParameter { ParameterName = parameter.Name, Value = parameter.Value } );
    			}
    			return m_Context.ExecuteStoreCommand( sql, parameters.ToArray( ) );
    		}
    		catch( Exception _ex )
    		{
    			Log.WriteException( string.Format( "Problem in DataManager.Delete(Expression) for {0} {1}", "AreaMembership", sql ), _ex );
    			throw;
    		}
    	}
    }
    
    public partial class AreaManager : DataManager<IArea, Area>, IAreaManager, IDataManager
    {
    	public AreaManager ( IDataManagerFactory _factory, DrinkReportingEntities _context )
    	{
    		m_Factory = _factory;
    		m_Context = _context;
    	}
    
    	public override IArea Create( )
    	{
    		var item = new Area( );
    		item.AreaId = Guid.NewGuid( );
    		item.IsNew = true;
    		item.ModifiedOn = DateTime.Now;
    		OnCreated( item );
    		return item;
    	}
    
    	public override void Delete( Guid _id )
        {
    		// If we knew that there were no foreign keys involved, we could instantiate an item and set its id and call delete without
    		// first going to the database; but, if a foreign key is involved, that short-cut will cause problems in the context.
    		// Thus, it is safer to go get the item, even though it costs a database read.
    
    		// The item to be deleted might have just been added in this context. Check there first, because it won't be in the database.
    
    		try
    		{
    			var addedEntries = m_Context.ObjectStateManager.GetObjectStateEntries( EntityState.Added );
    			var match = addedEntries.FirstOrDefault( c => ( ( Area ) c.Entity ).AreaId == _id );
    			IArea item = match == null ? Get( _id ) : match.Entity as IArea;
    			Delete( item );
    		}
    		catch ( Exception _ex )
    		{
    			Log.WriteException( string.Format( "Problem in DataManager.Delete for {0} - {1}.", "Area", _id ), _ex );
    			throw;
    		}
        }
    
    	public override int Delete( Expression<Func<IArea, bool>> _predicate )
    	{
    		string sql = string.Empty;
    		try
    		{
    			var query = ( ObjectQuery<Guid>) m_Context.GetObjectSet<IArea, Area>( )
    				.Where( _predicate )
    				.Select( item => item.AreaId );
    			sql = string.Format( "DELETE FROM [Areas] WHERE [AreaId] IN ({0})", query.ToTraceString( ) );
    			var parameters = new List<System.Data.SqlClient.SqlParameter>( );
    			foreach ( ObjectParameter parameter in query.Parameters )
    			{
    				parameters.Add( new System.Data.SqlClient.SqlParameter { ParameterName = parameter.Name, Value = parameter.Value } );
    			}
    			return m_Context.ExecuteStoreCommand( sql, parameters.ToArray( ) );
    		}
    		catch( Exception _ex )
    		{
    			Log.WriteException( string.Format( "Problem in DataManager.Delete(Expression) for {0} {1}", "Area", sql ), _ex );
    			throw;
    		}
    	}
    }
    
    public partial class ColumnManager : DataManager<IColumn, Column>, IColumnManager, IDataManager
    {
    	public ColumnManager ( IDataManagerFactory _factory, DrinkReportingEntities _context )
    	{
    		m_Factory = _factory;
    		m_Context = _context;
    	}
    
    	public override IColumn Create( )
    	{
    		var item = new Column( );
    		item.ColumnId = Guid.NewGuid( );
    		item.IsNew = true;
    		item.ModifiedOn = DateTime.Now;
    		OnCreated( item );
    		return item;
    	}
    
    	public override void Delete( Guid _id )
        {
    		// If we knew that there were no foreign keys involved, we could instantiate an item and set its id and call delete without
    		// first going to the database; but, if a foreign key is involved, that short-cut will cause problems in the context.
    		// Thus, it is safer to go get the item, even though it costs a database read.
    
    		// The item to be deleted might have just been added in this context. Check there first, because it won't be in the database.
    
    		try
    		{
    			var addedEntries = m_Context.ObjectStateManager.GetObjectStateEntries( EntityState.Added );
    			var match = addedEntries.FirstOrDefault( c => ( ( Column ) c.Entity ).ColumnId == _id );
    			IColumn item = match == null ? Get( _id ) : match.Entity as IColumn;
    			Delete( item );
    		}
    		catch ( Exception _ex )
    		{
    			Log.WriteException( string.Format( "Problem in DataManager.Delete for {0} - {1}.", "Column", _id ), _ex );
    			throw;
    		}
        }
    
    	public override int Delete( Expression<Func<IColumn, bool>> _predicate )
    	{
    		string sql = string.Empty;
    		try
    		{
    			var query = ( ObjectQuery<Guid>) m_Context.GetObjectSet<IColumn, Column>( )
    				.Where( _predicate )
    				.Select( item => item.ColumnId );
    			sql = string.Format( "DELETE FROM [Columns] WHERE [ColumnId] IN ({0})", query.ToTraceString( ) );
    			var parameters = new List<System.Data.SqlClient.SqlParameter>( );
    			foreach ( ObjectParameter parameter in query.Parameters )
    			{
    				parameters.Add( new System.Data.SqlClient.SqlParameter { ParameterName = parameter.Name, Value = parameter.Value } );
    			}
    			return m_Context.ExecuteStoreCommand( sql, parameters.ToArray( ) );
    		}
    		catch( Exception _ex )
    		{
    			Log.WriteException( string.Format( "Problem in DataManager.Delete(Expression) for {0} {1}", "Column", sql ), _ex );
    			throw;
    		}
    	}
    }
    
    public partial class DeviceManager : DataManager<IDevice, Device>, IDeviceManager, IDataManager
    {
    	public DeviceManager ( IDataManagerFactory _factory, DrinkReportingEntities _context )
    	{
    		m_Factory = _factory;
    		m_Context = _context;
    	}
    
    	public override IDevice Create( )
    	{
    		var item = new Device( );
    		item.DeviceId = Guid.NewGuid( );
    		item.IsNew = true;
    		item.ModifiedOn = DateTime.Now;
    		OnCreated( item );
    		return item;
    	}
    
    	public override void Delete( Guid _id )
        {
    		// If we knew that there were no foreign keys involved, we could instantiate an item and set its id and call delete without
    		// first going to the database; but, if a foreign key is involved, that short-cut will cause problems in the context.
    		// Thus, it is safer to go get the item, even though it costs a database read.
    
    		// The item to be deleted might have just been added in this context. Check there first, because it won't be in the database.
    
    		try
    		{
    			var addedEntries = m_Context.ObjectStateManager.GetObjectStateEntries( EntityState.Added );
    			var match = addedEntries.FirstOrDefault( c => ( ( Device ) c.Entity ).DeviceId == _id );
    			IDevice item = match == null ? Get( _id ) : match.Entity as IDevice;
    			Delete( item );
    		}
    		catch ( Exception _ex )
    		{
    			Log.WriteException( string.Format( "Problem in DataManager.Delete for {0} - {1}.", "Device", _id ), _ex );
    			throw;
    		}
        }
    
    	public override int Delete( Expression<Func<IDevice, bool>> _predicate )
    	{
    		string sql = string.Empty;
    		try
    		{
    			var query = ( ObjectQuery<Guid>) m_Context.GetObjectSet<IDevice, Device>( )
    				.Where( _predicate )
    				.Select( item => item.DeviceId );
    			sql = string.Format( "DELETE FROM [Devices] WHERE [DeviceId] IN ({0})", query.ToTraceString( ) );
    			var parameters = new List<System.Data.SqlClient.SqlParameter>( );
    			foreach ( ObjectParameter parameter in query.Parameters )
    			{
    				parameters.Add( new System.Data.SqlClient.SqlParameter { ParameterName = parameter.Name, Value = parameter.Value } );
    			}
    			return m_Context.ExecuteStoreCommand( sql, parameters.ToArray( ) );
    		}
    		catch( Exception _ex )
    		{
    			Log.WriteException( string.Format( "Problem in DataManager.Delete(Expression) for {0} {1}", "Device", sql ), _ex );
    			throw;
    		}
    	}
    }
    
    public partial class OrganizationManager : DataManager<IOrganization, Organization>, IOrganizationManager, IDataManager
    {
    	public OrganizationManager ( IDataManagerFactory _factory, DrinkReportingEntities _context )
    	{
    		m_Factory = _factory;
    		m_Context = _context;
    	}
    
    	public override IOrganization Create( )
    	{
    		var item = new Organization( );
    		item.OrganizationId = Guid.NewGuid( );
    		item.IsNew = true;
    		item.ModifiedOn = DateTime.Now;
    		OnCreated( item );
    		return item;
    	}
    
    	public override void Delete( Guid _id )
        {
    		// If we knew that there were no foreign keys involved, we could instantiate an item and set its id and call delete without
    		// first going to the database; but, if a foreign key is involved, that short-cut will cause problems in the context.
    		// Thus, it is safer to go get the item, even though it costs a database read.
    
    		// The item to be deleted might have just been added in this context. Check there first, because it won't be in the database.
    
    		try
    		{
    			var addedEntries = m_Context.ObjectStateManager.GetObjectStateEntries( EntityState.Added );
    			var match = addedEntries.FirstOrDefault( c => ( ( Organization ) c.Entity ).OrganizationId == _id );
    			IOrganization item = match == null ? Get( _id ) : match.Entity as IOrganization;
    			Delete( item );
    		}
    		catch ( Exception _ex )
    		{
    			Log.WriteException( string.Format( "Problem in DataManager.Delete for {0} - {1}.", "Organization", _id ), _ex );
    			throw;
    		}
        }
    
    	public override int Delete( Expression<Func<IOrganization, bool>> _predicate )
    	{
    		string sql = string.Empty;
    		try
    		{
    			var query = ( ObjectQuery<Guid>) m_Context.GetObjectSet<IOrganization, Organization>( )
    				.Where( _predicate )
    				.Select( item => item.OrganizationId );
    			sql = string.Format( "DELETE FROM [Organizations] WHERE [OrganizationId] IN ({0})", query.ToTraceString( ) );
    			var parameters = new List<System.Data.SqlClient.SqlParameter>( );
    			foreach ( ObjectParameter parameter in query.Parameters )
    			{
    				parameters.Add( new System.Data.SqlClient.SqlParameter { ParameterName = parameter.Name, Value = parameter.Value } );
    			}
    			return m_Context.ExecuteStoreCommand( sql, parameters.ToArray( ) );
    		}
    		catch( Exception _ex )
    		{
    			Log.WriteException( string.Format( "Problem in DataManager.Delete(Expression) for {0} {1}", "Organization", sql ), _ex );
    			throw;
    		}
    	}
    }
    
    public partial class ParameterManager : DataManager<IParameter, Parameter>, IParameterManager, IDataManager
    {
    	public ParameterManager ( IDataManagerFactory _factory, DrinkReportingEntities _context )
    	{
    		m_Factory = _factory;
    		m_Context = _context;
    	}
    
    	public override IParameter Create( )
    	{
    		var item = new Parameter( );
    		item.ParameterId = Guid.NewGuid( );
    		item.IsNew = true;
    		item.ModifiedOn = DateTime.Now;
    		OnCreated( item );
    		return item;
    	}
    
    	public override void Delete( Guid _id )
        {
    		// If we knew that there were no foreign keys involved, we could instantiate an item and set its id and call delete without
    		// first going to the database; but, if a foreign key is involved, that short-cut will cause problems in the context.
    		// Thus, it is safer to go get the item, even though it costs a database read.
    
    		// The item to be deleted might have just been added in this context. Check there first, because it won't be in the database.
    
    		try
    		{
    			var addedEntries = m_Context.ObjectStateManager.GetObjectStateEntries( EntityState.Added );
    			var match = addedEntries.FirstOrDefault( c => ( ( Parameter ) c.Entity ).ParameterId == _id );
    			IParameter item = match == null ? Get( _id ) : match.Entity as IParameter;
    			Delete( item );
    		}
    		catch ( Exception _ex )
    		{
    			Log.WriteException( string.Format( "Problem in DataManager.Delete for {0} - {1}.", "Parameter", _id ), _ex );
    			throw;
    		}
        }
    
    	public override int Delete( Expression<Func<IParameter, bool>> _predicate )
    	{
    		string sql = string.Empty;
    		try
    		{
    			var query = ( ObjectQuery<Guid>) m_Context.GetObjectSet<IParameter, Parameter>( )
    				.Where( _predicate )
    				.Select( item => item.ParameterId );
    			sql = string.Format( "DELETE FROM [Parameters] WHERE [ParameterId] IN ({0})", query.ToTraceString( ) );
    			var parameters = new List<System.Data.SqlClient.SqlParameter>( );
    			foreach ( ObjectParameter parameter in query.Parameters )
    			{
    				parameters.Add( new System.Data.SqlClient.SqlParameter { ParameterName = parameter.Name, Value = parameter.Value } );
    			}
    			return m_Context.ExecuteStoreCommand( sql, parameters.ToArray( ) );
    		}
    		catch( Exception _ex )
    		{
    			Log.WriteException( string.Format( "Problem in DataManager.Delete(Expression) for {0} {1}", "Parameter", sql ), _ex );
    			throw;
    		}
    	}
    }
    
    public partial class POSTicketItemManager : DataManager<IPOSTicketItem, POSTicketItem>, IPOSTicketItemManager, IDataManager
    {
    	public POSTicketItemManager ( IDataManagerFactory _factory, DrinkReportingEntities _context )
    	{
    		m_Factory = _factory;
    		m_Context = _context;
    	}
    
    	public override IPOSTicketItem Create( )
    	{
    		var item = new POSTicketItem( );
    		item.POSTicketItemId = Guid.NewGuid( );
    		item.IsNew = true;
    		item.ModifiedOn = DateTime.Now;
    		OnCreated( item );
    		return item;
    	}
    
    	public override void Delete( Guid _id )
        {
    		// If we knew that there were no foreign keys involved, we could instantiate an item and set its id and call delete without
    		// first going to the database; but, if a foreign key is involved, that short-cut will cause problems in the context.
    		// Thus, it is safer to go get the item, even though it costs a database read.
    
    		// The item to be deleted might have just been added in this context. Check there first, because it won't be in the database.
    
    		try
    		{
    			var addedEntries = m_Context.ObjectStateManager.GetObjectStateEntries( EntityState.Added );
    			var match = addedEntries.FirstOrDefault( c => ( ( POSTicketItem ) c.Entity ).POSTicketItemId == _id );
    			IPOSTicketItem item = match == null ? Get( _id ) : match.Entity as IPOSTicketItem;
    			Delete( item );
    		}
    		catch ( Exception _ex )
    		{
    			Log.WriteException( string.Format( "Problem in DataManager.Delete for {0} - {1}.", "POSTicketItem", _id ), _ex );
    			throw;
    		}
        }
    
    	public override int Delete( Expression<Func<IPOSTicketItem, bool>> _predicate )
    	{
    		string sql = string.Empty;
    		try
    		{
    			var query = ( ObjectQuery<Guid>) m_Context.GetObjectSet<IPOSTicketItem, POSTicketItem>( )
    				.Where( _predicate )
    				.Select( item => item.POSTicketItemId );
    			sql = string.Format( "DELETE FROM [POSTicketItems] WHERE [POSTicketItemId] IN ({0})", query.ToTraceString( ) );
    			var parameters = new List<System.Data.SqlClient.SqlParameter>( );
    			foreach ( ObjectParameter parameter in query.Parameters )
    			{
    				parameters.Add( new System.Data.SqlClient.SqlParameter { ParameterName = parameter.Name, Value = parameter.Value } );
    			}
    			return m_Context.ExecuteStoreCommand( sql, parameters.ToArray( ) );
    		}
    		catch( Exception _ex )
    		{
    			Log.WriteException( string.Format( "Problem in DataManager.Delete(Expression) for {0} {1}", "POSTicketItem", sql ), _ex );
    			throw;
    		}
    	}
    }
    
    public partial class PourManager : DataManager<IPour, Pour>, IPourManager, IDataManager
    {
    	public PourManager ( IDataManagerFactory _factory, DrinkReportingEntities _context )
    	{
    		m_Factory = _factory;
    		m_Context = _context;
    	}
    
    	public override IPour Create( )
    	{
    		var item = new Pour( );
    		item.PourId = Guid.NewGuid( );
    		item.IsNew = true;
    		item.ModifiedOn = DateTime.Now;
    		OnCreated( item );
    		return item;
    	}
    
    	public override void Delete( Guid _id )
        {
    		// If we knew that there were no foreign keys involved, we could instantiate an item and set its id and call delete without
    		// first going to the database; but, if a foreign key is involved, that short-cut will cause problems in the context.
    		// Thus, it is safer to go get the item, even though it costs a database read.
    
    		// The item to be deleted might have just been added in this context. Check there first, because it won't be in the database.
    
    		try
    		{
    			var addedEntries = m_Context.ObjectStateManager.GetObjectStateEntries( EntityState.Added );
    			var match = addedEntries.FirstOrDefault( c => ( ( Pour ) c.Entity ).PourId == _id );
    			IPour item = match == null ? Get( _id ) : match.Entity as IPour;
    			Delete( item );
    		}
    		catch ( Exception _ex )
    		{
    			Log.WriteException( string.Format( "Problem in DataManager.Delete for {0} - {1}.", "Pour", _id ), _ex );
    			throw;
    		}
        }
    
    	public override int Delete( Expression<Func<IPour, bool>> _predicate )
    	{
    		string sql = string.Empty;
    		try
    		{
    			var query = ( ObjectQuery<Guid>) m_Context.GetObjectSet<IPour, Pour>( )
    				.Where( _predicate )
    				.Select( item => item.PourId );
    			sql = string.Format( "DELETE FROM [Pours] WHERE [PourId] IN ({0})", query.ToTraceString( ) );
    			var parameters = new List<System.Data.SqlClient.SqlParameter>( );
    			foreach ( ObjectParameter parameter in query.Parameters )
    			{
    				parameters.Add( new System.Data.SqlClient.SqlParameter { ParameterName = parameter.Name, Value = parameter.Value } );
    			}
    			return m_Context.ExecuteStoreCommand( sql, parameters.ToArray( ) );
    		}
    		catch( Exception _ex )
    		{
    			Log.WriteException( string.Format( "Problem in DataManager.Delete(Expression) for {0} {1}", "Pour", sql ), _ex );
    			throw;
    		}
    	}
    }
    
    public partial class ReportManager : DataManager<IReport, Report>, IReportManager, IDataManager
    {
    	public ReportManager ( IDataManagerFactory _factory, DrinkReportingEntities _context )
    	{
    		m_Factory = _factory;
    		m_Context = _context;
    	}
    
    	public override IReport Create( )
    	{
    		var item = new Report( );
    		item.ReportId = Guid.NewGuid( );
    		item.IsNew = true;
    		item.ModifiedOn = DateTime.Now;
    		OnCreated( item );
    		return item;
    	}
    
    	public override void Delete( Guid _id )
        {
    		// If we knew that there were no foreign keys involved, we could instantiate an item and set its id and call delete without
    		// first going to the database; but, if a foreign key is involved, that short-cut will cause problems in the context.
    		// Thus, it is safer to go get the item, even though it costs a database read.
    
    		// The item to be deleted might have just been added in this context. Check there first, because it won't be in the database.
    
    		try
    		{
    			var addedEntries = m_Context.ObjectStateManager.GetObjectStateEntries( EntityState.Added );
    			var match = addedEntries.FirstOrDefault( c => ( ( Report ) c.Entity ).ReportId == _id );
    			IReport item = match == null ? Get( _id ) : match.Entity as IReport;
    			Delete( item );
    		}
    		catch ( Exception _ex )
    		{
    			Log.WriteException( string.Format( "Problem in DataManager.Delete for {0} - {1}.", "Report", _id ), _ex );
    			throw;
    		}
        }
    
    	public override int Delete( Expression<Func<IReport, bool>> _predicate )
    	{
    		string sql = string.Empty;
    		try
    		{
    			var query = ( ObjectQuery<Guid>) m_Context.GetObjectSet<IReport, Report>( )
    				.Where( _predicate )
    				.Select( item => item.ReportId );
    			sql = string.Format( "DELETE FROM [Reports] WHERE [ReportId] IN ({0})", query.ToTraceString( ) );
    			var parameters = new List<System.Data.SqlClient.SqlParameter>( );
    			foreach ( ObjectParameter parameter in query.Parameters )
    			{
    				parameters.Add( new System.Data.SqlClient.SqlParameter { ParameterName = parameter.Name, Value = parameter.Value } );
    			}
    			return m_Context.ExecuteStoreCommand( sql, parameters.ToArray( ) );
    		}
    		catch( Exception _ex )
    		{
    			Log.WriteException( string.Format( "Problem in DataManager.Delete(Expression) for {0} {1}", "Report", sql ), _ex );
    			throw;
    		}
    	}
    }
    
    public partial class SchemaManager : DataManager<ISchema, Schema>, ISchemaManager, IDataManager
    {
    	public SchemaManager ( IDataManagerFactory _factory, DrinkReportingEntities _context )
    	{
    		m_Factory = _factory;
    		m_Context = _context;
    	}
    
    	public override ISchema Create( )
    	{
    		var item = new Schema( );
    		item.SchemaId = Guid.NewGuid( );
    		item.IsNew = true;
    		item.ModifiedOn = DateTime.Now;
    		OnCreated( item );
    		return item;
    	}
    
    	public override void Delete( Guid _id )
        {
    		// If we knew that there were no foreign keys involved, we could instantiate an item and set its id and call delete without
    		// first going to the database; but, if a foreign key is involved, that short-cut will cause problems in the context.
    		// Thus, it is safer to go get the item, even though it costs a database read.
    
    		// The item to be deleted might have just been added in this context. Check there first, because it won't be in the database.
    
    		try
    		{
    			var addedEntries = m_Context.ObjectStateManager.GetObjectStateEntries( EntityState.Added );
    			var match = addedEntries.FirstOrDefault( c => ( ( Schema ) c.Entity ).SchemaId == _id );
    			ISchema item = match == null ? Get( _id ) : match.Entity as ISchema;
    			Delete( item );
    		}
    		catch ( Exception _ex )
    		{
    			Log.WriteException( string.Format( "Problem in DataManager.Delete for {0} - {1}.", "Schema", _id ), _ex );
    			throw;
    		}
        }
    
    	public override int Delete( Expression<Func<ISchema, bool>> _predicate )
    	{
    		string sql = string.Empty;
    		try
    		{
    			var query = ( ObjectQuery<Guid>) m_Context.GetObjectSet<ISchema, Schema>( )
    				.Where( _predicate )
    				.Select( item => item.SchemaId );
    			sql = string.Format( "DELETE FROM [Schemata] WHERE [SchemaId] IN ({0})", query.ToTraceString( ) );
    			var parameters = new List<System.Data.SqlClient.SqlParameter>( );
    			foreach ( ObjectParameter parameter in query.Parameters )
    			{
    				parameters.Add( new System.Data.SqlClient.SqlParameter { ParameterName = parameter.Name, Value = parameter.Value } );
    			}
    			return m_Context.ExecuteStoreCommand( sql, parameters.ToArray( ) );
    		}
    		catch( Exception _ex )
    		{
    			Log.WriteException( string.Format( "Problem in DataManager.Delete(Expression) for {0} {1}", "Schema", sql ), _ex );
    			throw;
    		}
    	}
    }
    
    public partial class SecurityViewManager : DataManager<ISecurityView, SecurityView>, ISecurityViewManager, IDataManager
    {
    	public SecurityViewManager ( IDataManagerFactory _factory, DrinkReportingEntities _context )
    	{
    		m_Factory = _factory;
    		m_Context = _context;
    	}
    
    	public override ISecurityView Create( )
    	{
    		var item = new SecurityView( );
    		item.SecurityViewId = Guid.NewGuid( );
    		item.IsNew = true;
    		item.ModifiedOn = DateTime.Now;
    		OnCreated( item );
    		return item;
    	}
    
    	public override void Delete( Guid _id )
        {
    		// If we knew that there were no foreign keys involved, we could instantiate an item and set its id and call delete without
    		// first going to the database; but, if a foreign key is involved, that short-cut will cause problems in the context.
    		// Thus, it is safer to go get the item, even though it costs a database read.
    
    		// The item to be deleted might have just been added in this context. Check there first, because it won't be in the database.
    
    		try
    		{
    			var addedEntries = m_Context.ObjectStateManager.GetObjectStateEntries( EntityState.Added );
    			var match = addedEntries.FirstOrDefault( c => ( ( SecurityView ) c.Entity ).SecurityViewId == _id );
    			ISecurityView item = match == null ? Get( _id ) : match.Entity as ISecurityView;
    			Delete( item );
    		}
    		catch ( Exception _ex )
    		{
    			Log.WriteException( string.Format( "Problem in DataManager.Delete for {0} - {1}.", "SecurityView", _id ), _ex );
    			throw;
    		}
        }
    
    	public override int Delete( Expression<Func<ISecurityView, bool>> _predicate )
    	{
    		string sql = string.Empty;
    		try
    		{
    			var query = ( ObjectQuery<Guid>) m_Context.GetObjectSet<ISecurityView, SecurityView>( )
    				.Where( _predicate )
    				.Select( item => item.SecurityViewId );
    			sql = string.Format( "DELETE FROM [SecurityViews] WHERE [SecurityViewId] IN ({0})", query.ToTraceString( ) );
    			var parameters = new List<System.Data.SqlClient.SqlParameter>( );
    			foreach ( ObjectParameter parameter in query.Parameters )
    			{
    				parameters.Add( new System.Data.SqlClient.SqlParameter { ParameterName = parameter.Name, Value = parameter.Value } );
    			}
    			return m_Context.ExecuteStoreCommand( sql, parameters.ToArray( ) );
    		}
    		catch( Exception _ex )
    		{
    			Log.WriteException( string.Format( "Problem in DataManager.Delete(Expression) for {0} {1}", "SecurityView", sql ), _ex );
    			throw;
    		}
    	}
    }
    
    public partial class SessionManager : DataManager<ISession, Session>, ISessionManager, IDataManager
    {
    	public SessionManager ( IDataManagerFactory _factory, DrinkReportingEntities _context )
    	{
    		m_Factory = _factory;
    		m_Context = _context;
    	}
    
    	public override ISession Create( )
    	{
    		var item = new Session( );
    		item.SessionId = Guid.NewGuid( );
    		item.IsNew = true;
    		item.ModifiedOn = DateTime.Now;
    		OnCreated( item );
    		return item;
    	}
    
    	public override void Delete( Guid _id )
        {
    		// If we knew that there were no foreign keys involved, we could instantiate an item and set its id and call delete without
    		// first going to the database; but, if a foreign key is involved, that short-cut will cause problems in the context.
    		// Thus, it is safer to go get the item, even though it costs a database read.
    
    		// The item to be deleted might have just been added in this context. Check there first, because it won't be in the database.
    
    		try
    		{
    			var addedEntries = m_Context.ObjectStateManager.GetObjectStateEntries( EntityState.Added );
    			var match = addedEntries.FirstOrDefault( c => ( ( Session ) c.Entity ).SessionId == _id );
    			ISession item = match == null ? Get( _id ) : match.Entity as ISession;
    			Delete( item );
    		}
    		catch ( Exception _ex )
    		{
    			Log.WriteException( string.Format( "Problem in DataManager.Delete for {0} - {1}.", "Session", _id ), _ex );
    			throw;
    		}
        }
    
    	public override int Delete( Expression<Func<ISession, bool>> _predicate )
    	{
    		string sql = string.Empty;
    		try
    		{
    			var query = ( ObjectQuery<Guid>) m_Context.GetObjectSet<ISession, Session>( )
    				.Where( _predicate )
    				.Select( item => item.SessionId );
    			sql = string.Format( "DELETE FROM [Sessions] WHERE [SessionId] IN ({0})", query.ToTraceString( ) );
    			var parameters = new List<System.Data.SqlClient.SqlParameter>( );
    			foreach ( ObjectParameter parameter in query.Parameters )
    			{
    				parameters.Add( new System.Data.SqlClient.SqlParameter { ParameterName = parameter.Name, Value = parameter.Value } );
    			}
    			return m_Context.ExecuteStoreCommand( sql, parameters.ToArray( ) );
    		}
    		catch( Exception _ex )
    		{
    			Log.WriteException( string.Format( "Problem in DataManager.Delete(Expression) for {0} {1}", "Session", sql ), _ex );
    			throw;
    		}
    	}
    }
    
    public partial class UPCManager : DataManager<IUPC, UPC>, IUPCManager, IDataManager
    {
    	public UPCManager ( IDataManagerFactory _factory, DrinkReportingEntities _context )
    	{
    		m_Factory = _factory;
    		m_Context = _context;
    	}
    
    	public override IUPC Create( )
    	{
    		var item = new UPC( );
    		item.UPCId = Guid.NewGuid( );
    		item.IsNew = true;
    		item.ModifiedOn = DateTime.Now;
    		OnCreated( item );
    		return item;
    	}
    
    	public override void Delete( Guid _id )
        {
    		// If we knew that there were no foreign keys involved, we could instantiate an item and set its id and call delete without
    		// first going to the database; but, if a foreign key is involved, that short-cut will cause problems in the context.
    		// Thus, it is safer to go get the item, even though it costs a database read.
    
    		// The item to be deleted might have just been added in this context. Check there first, because it won't be in the database.
    
    		try
    		{
    			var addedEntries = m_Context.ObjectStateManager.GetObjectStateEntries( EntityState.Added );
    			var match = addedEntries.FirstOrDefault( c => ( ( UPC ) c.Entity ).UPCId == _id );
    			IUPC item = match == null ? Get( _id ) : match.Entity as IUPC;
    			Delete( item );
    		}
    		catch ( Exception _ex )
    		{
    			Log.WriteException( string.Format( "Problem in DataManager.Delete for {0} - {1}.", "UPC", _id ), _ex );
    			throw;
    		}
        }
    
    	public override int Delete( Expression<Func<IUPC, bool>> _predicate )
    	{
    		string sql = string.Empty;
    		try
    		{
    			var query = ( ObjectQuery<Guid>) m_Context.GetObjectSet<IUPC, UPC>( )
    				.Where( _predicate )
    				.Select( item => item.UPCId );
    			sql = string.Format( "DELETE FROM [UPCs] WHERE [UPCId] IN ({0})", query.ToTraceString( ) );
    			var parameters = new List<System.Data.SqlClient.SqlParameter>( );
    			foreach ( ObjectParameter parameter in query.Parameters )
    			{
    				parameters.Add( new System.Data.SqlClient.SqlParameter { ParameterName = parameter.Name, Value = parameter.Value } );
    			}
    			return m_Context.ExecuteStoreCommand( sql, parameters.ToArray( ) );
    		}
    		catch( Exception _ex )
    		{
    			Log.WriteException( string.Format( "Problem in DataManager.Delete(Expression) for {0} {1}", "UPC", sql ), _ex );
    			throw;
    		}
    	}
    }
    
    public partial class UserGroupMembershipManager : DataManager<IUserGroupMembership, UserGroupMembership>, IUserGroupMembershipManager, IDataManager
    {
    	public UserGroupMembershipManager ( IDataManagerFactory _factory, DrinkReportingEntities _context )
    	{
    		m_Factory = _factory;
    		m_Context = _context;
    	}
    
    	public override IUserGroupMembership Create( )
    	{
    		var item = new UserGroupMembership( );
    		item.UserGroupMembershipId = Guid.NewGuid( );
    		item.IsNew = true;
    		item.ModifiedOn = DateTime.Now;
    		OnCreated( item );
    		return item;
    	}
    
    	public override void Delete( Guid _id )
        {
    		// If we knew that there were no foreign keys involved, we could instantiate an item and set its id and call delete without
    		// first going to the database; but, if a foreign key is involved, that short-cut will cause problems in the context.
    		// Thus, it is safer to go get the item, even though it costs a database read.
    
    		// The item to be deleted might have just been added in this context. Check there first, because it won't be in the database.
    
    		try
    		{
    			var addedEntries = m_Context.ObjectStateManager.GetObjectStateEntries( EntityState.Added );
    			var match = addedEntries.FirstOrDefault( c => ( ( UserGroupMembership ) c.Entity ).UserGroupMembershipId == _id );
    			IUserGroupMembership item = match == null ? Get( _id ) : match.Entity as IUserGroupMembership;
    			Delete( item );
    		}
    		catch ( Exception _ex )
    		{
    			Log.WriteException( string.Format( "Problem in DataManager.Delete for {0} - {1}.", "UserGroupMembership", _id ), _ex );
    			throw;
    		}
        }
    
    	public override int Delete( Expression<Func<IUserGroupMembership, bool>> _predicate )
    	{
    		string sql = string.Empty;
    		try
    		{
    			var query = ( ObjectQuery<Guid>) m_Context.GetObjectSet<IUserGroupMembership, UserGroupMembership>( )
    				.Where( _predicate )
    				.Select( item => item.UserGroupMembershipId );
    			sql = string.Format( "DELETE FROM [UserGroupMemberships] WHERE [UserGroupMembershipId] IN ({0})", query.ToTraceString( ) );
    			var parameters = new List<System.Data.SqlClient.SqlParameter>( );
    			foreach ( ObjectParameter parameter in query.Parameters )
    			{
    				parameters.Add( new System.Data.SqlClient.SqlParameter { ParameterName = parameter.Name, Value = parameter.Value } );
    			}
    			return m_Context.ExecuteStoreCommand( sql, parameters.ToArray( ) );
    		}
    		catch( Exception _ex )
    		{
    			Log.WriteException( string.Format( "Problem in DataManager.Delete(Expression) for {0} {1}", "UserGroupMembership", sql ), _ex );
    			throw;
    		}
    	}
    }
    
    public partial class UserGroupManager : DataManager<IUserGroup, UserGroup>, IUserGroupManager, IDataManager
    {
    	public UserGroupManager ( IDataManagerFactory _factory, DrinkReportingEntities _context )
    	{
    		m_Factory = _factory;
    		m_Context = _context;
    	}
    
    	public override IUserGroup Create( )
    	{
    		var item = new UserGroup( );
    		item.UserGroupId = Guid.NewGuid( );
    		item.IsNew = true;
    		item.ModifiedOn = DateTime.Now;
    		OnCreated( item );
    		return item;
    	}
    
    	public override void Delete( Guid _id )
        {
    		// If we knew that there were no foreign keys involved, we could instantiate an item and set its id and call delete without
    		// first going to the database; but, if a foreign key is involved, that short-cut will cause problems in the context.
    		// Thus, it is safer to go get the item, even though it costs a database read.
    
    		// The item to be deleted might have just been added in this context. Check there first, because it won't be in the database.
    
    		try
    		{
    			var addedEntries = m_Context.ObjectStateManager.GetObjectStateEntries( EntityState.Added );
    			var match = addedEntries.FirstOrDefault( c => ( ( UserGroup ) c.Entity ).UserGroupId == _id );
    			IUserGroup item = match == null ? Get( _id ) : match.Entity as IUserGroup;
    			Delete( item );
    		}
    		catch ( Exception _ex )
    		{
    			Log.WriteException( string.Format( "Problem in DataManager.Delete for {0} - {1}.", "UserGroup", _id ), _ex );
    			throw;
    		}
        }
    
    	public override int Delete( Expression<Func<IUserGroup, bool>> _predicate )
    	{
    		string sql = string.Empty;
    		try
    		{
    			var query = ( ObjectQuery<Guid>) m_Context.GetObjectSet<IUserGroup, UserGroup>( )
    				.Where( _predicate )
    				.Select( item => item.UserGroupId );
    			sql = string.Format( "DELETE FROM [UserGroups] WHERE [UserGroupId] IN ({0})", query.ToTraceString( ) );
    			var parameters = new List<System.Data.SqlClient.SqlParameter>( );
    			foreach ( ObjectParameter parameter in query.Parameters )
    			{
    				parameters.Add( new System.Data.SqlClient.SqlParameter { ParameterName = parameter.Name, Value = parameter.Value } );
    			}
    			return m_Context.ExecuteStoreCommand( sql, parameters.ToArray( ) );
    		}
    		catch( Exception _ex )
    		{
    			Log.WriteException( string.Format( "Problem in DataManager.Delete(Expression) for {0} {1}", "UserGroup", sql ), _ex );
    			throw;
    		}
    	}
    }
    
    public partial class UserGroupXOrganizationManager : DataManager<IUserGroupXOrganization, UserGroupXOrganization>, IUserGroupXOrganizationManager, IDataManager
    {
    	public UserGroupXOrganizationManager ( IDataManagerFactory _factory, DrinkReportingEntities _context )
    	{
    		m_Factory = _factory;
    		m_Context = _context;
    	}
    
    	public override IUserGroupXOrganization Create( )
    	{
    		var item = new UserGroupXOrganization( );
    		item.UserGroupXOrganizationId = Guid.NewGuid( );
    		item.IsNew = true;
    		item.ModifiedOn = DateTime.Now;
    		OnCreated( item );
    		return item;
    	}
    
    	public override void Delete( Guid _id )
        {
    		// If we knew that there were no foreign keys involved, we could instantiate an item and set its id and call delete without
    		// first going to the database; but, if a foreign key is involved, that short-cut will cause problems in the context.
    		// Thus, it is safer to go get the item, even though it costs a database read.
    
    		// The item to be deleted might have just been added in this context. Check there first, because it won't be in the database.
    
    		try
    		{
    			var addedEntries = m_Context.ObjectStateManager.GetObjectStateEntries( EntityState.Added );
    			var match = addedEntries.FirstOrDefault( c => ( ( UserGroupXOrganization ) c.Entity ).UserGroupXOrganizationId == _id );
    			IUserGroupXOrganization item = match == null ? Get( _id ) : match.Entity as IUserGroupXOrganization;
    			Delete( item );
    		}
    		catch ( Exception _ex )
    		{
    			Log.WriteException( string.Format( "Problem in DataManager.Delete for {0} - {1}.", "UserGroupXOrganization", _id ), _ex );
    			throw;
    		}
        }
    
    	public override int Delete( Expression<Func<IUserGroupXOrganization, bool>> _predicate )
    	{
    		string sql = string.Empty;
    		try
    		{
    			var query = ( ObjectQuery<Guid>) m_Context.GetObjectSet<IUserGroupXOrganization, UserGroupXOrganization>( )
    				.Where( _predicate )
    				.Select( item => item.UserGroupXOrganizationId );
    			sql = string.Format( "DELETE FROM [UserGroupXOrganizations] WHERE [UserGroupXOrganizationId] IN ({0})", query.ToTraceString( ) );
    			var parameters = new List<System.Data.SqlClient.SqlParameter>( );
    			foreach ( ObjectParameter parameter in query.Parameters )
    			{
    				parameters.Add( new System.Data.SqlClient.SqlParameter { ParameterName = parameter.Name, Value = parameter.Value } );
    			}
    			return m_Context.ExecuteStoreCommand( sql, parameters.ToArray( ) );
    		}
    		catch( Exception _ex )
    		{
    			Log.WriteException( string.Format( "Problem in DataManager.Delete(Expression) for {0} {1}", "UserGroupXOrganization", sql ), _ex );
    			throw;
    		}
    	}
    }
    
    public partial class UserManager : DataManager<IUser, User>, IUserManager, IDataManager
    {
    	public UserManager ( IDataManagerFactory _factory, DrinkReportingEntities _context )
    	{
    		m_Factory = _factory;
    		m_Context = _context;
    	}
    
    	public override IUser Create( )
    	{
    		var item = new User( );
    		item.UserId = Guid.NewGuid( );
    		item.IsNew = true;
    		item.ModifiedOn = DateTime.Now;
    		OnCreated( item );
    		return item;
    	}
    
    	public override void Delete( Guid _id )
        {
    		// If we knew that there were no foreign keys involved, we could instantiate an item and set its id and call delete without
    		// first going to the database; but, if a foreign key is involved, that short-cut will cause problems in the context.
    		// Thus, it is safer to go get the item, even though it costs a database read.
    
    		// The item to be deleted might have just been added in this context. Check there first, because it won't be in the database.
    
    		try
    		{
    			var addedEntries = m_Context.ObjectStateManager.GetObjectStateEntries( EntityState.Added );
    			var match = addedEntries.FirstOrDefault( c => ( ( User ) c.Entity ).UserId == _id );
    			IUser item = match == null ? Get( _id ) : match.Entity as IUser;
    			Delete( item );
    		}
    		catch ( Exception _ex )
    		{
    			Log.WriteException( string.Format( "Problem in DataManager.Delete for {0} - {1}.", "User", _id ), _ex );
    			throw;
    		}
        }
    
    	public override int Delete( Expression<Func<IUser, bool>> _predicate )
    	{
    		string sql = string.Empty;
    		try
    		{
    			var query = ( ObjectQuery<Guid>) m_Context.GetObjectSet<IUser, User>( )
    				.Where( _predicate )
    				.Select( item => item.UserId );
    			sql = string.Format( "DELETE FROM [Users] WHERE [UserId] IN ({0})", query.ToTraceString( ) );
    			var parameters = new List<System.Data.SqlClient.SqlParameter>( );
    			foreach ( ObjectParameter parameter in query.Parameters )
    			{
    				parameters.Add( new System.Data.SqlClient.SqlParameter { ParameterName = parameter.Name, Value = parameter.Value } );
    			}
    			return m_Context.ExecuteStoreCommand( sql, parameters.ToArray( ) );
    		}
    		catch( Exception _ex )
    		{
    			Log.WriteException( string.Format( "Problem in DataManager.Delete(Expression) for {0} {1}", "User", sql ), _ex );
    			throw;
    		}
    	}
    }
}
